* HRobots

HRobots are robots, written in Haskell programming language, that can fight on a virtual arena, provided by NetRobots project at https://github.com/massimo-zaniboni/netrobots

* Installation

** Stack

Install in Debian

  sudo aptitude install libzmq3 libzmq3-dev pkg-config

Build the package under Stack

  stack build

Test if the robot can start without error messages, with

  stack exec hrobots 127.0.0.1 1234 classic test

then press ctr-c because the robot will wait (forever) for the server connection.

** Nix

  ./generate-nix-project.sh
  nix-shell -I . --command 'cabal build'

** Server 

The Netrobots server is on repo https://github.com/massimo-zaniboni/netrobots

* Communication Big Picture

The HRobot client specify a command to send to the server, using Protocol Buffers. See the file netrobots.proto

Protocol Buffers convert the message to a binary content.

ZeroMQ is used for sending the message to the NetRobots server.

The NetRobots server respond with a message received from HRobot, through ZeroMQ, and it is converted to Haskell data structures using Protocol Buffers.

It is "complicated" because the server is meant to support robots written in multiple programming languages in fast way.

* Project Tasks

TODO create a simple demo app that connect to the server

TODO convert Rabbit or other code, without using Functional Reactive Programming Approach

* Low Level Things

** DONE demo di comunicazione
Preparare un codice IO che usa ZMQ per connettersi, lanciare qualche comando e vedere come reagisce.

Non pretendere che sia quello finale da usare come Skeleton, ma deve essere solo un modo per capire come usare ZMQ e vedere se tutto gira.

** Varie

TODO vedere se uno deve anche installare le librerie per ZMQ nel sistema linux e fornire le istruzioni relative


*** TODO Rendere parametrico server e client

DONE lo schema classico di un main di un robot e:`
- indirizzo del server
- nome user-friendly del robot
- modello robot
- parametri di funzionamento del robot
Questo permette di lanciare` piu` Robot in piu` versioni e vedere come si comportano

DONE aggiornare la documentazione

*** DONE rendere il ticket del tempo parametrico alla partenza del server e calibrarlo sulla velocita` del network
:LOGBOOK:
CLOCK: [2015-10-15 Thu 22:49]--[2015-10-16 Fri 00:03] =>  1:14
CLOCK: [2015-10-15 Thu 20:48]--[2015-10-15 Thu 21:45] =>  0:57
CLOCK: [2015-10-15 Thu 19:00]--[2015-10-15 Thu 19:30] =>  0:30
CLOCK: [2015-10-15 Thu 18:00]--[2015-10-15 Thu 18:53] =>  0:53
:END:

DONE indicare il ticket di tempo entro il quale si eseguira` il prossimo comando in modo esplicito nella API:
- estendere il server NETROBOTS
- estendere il client Haskell

DONE togliere commenti XXX e Debug mode quando gira tutto

DONE testare la velocita` e accuratezza di alcuni parametri

DONE testare Rabbit e altri robot sotto Python

DONE convertire robot sotto Python ad accettare server + zmq port, come ho fatto con Haskell

DONE eseguire il ticket di simulazione senza usare un clock, ma eseguendo diversi tick, calcolare lo status e poi con lo status finale attendere il wakeup e tornare il risultato finale

CANCELLED provare una modalita` di max-speed del network per capire qual e` la massima velocita` raggiungibile, in particolare segnalare se alcuni clients saltano dei comandi, in particolare sulla linea di comando come LOG ogni tot X interazioni, a livello di statistica: non serve dato che 1/2 pacchetti per secondo sono alla portata di ogni network

*** Varie da classificare 

TODO when the repo is mature, removing from local GITLAB repo, and put on GitHub

TODO study some library making calculations on distance, direction, and so on, also using aproximation 

TODO add a license file (GPL probably)

TODO add an AUTHOR file referencing other authors

TODO merge with the better board in Javascript

TODO preparare una VM in VAGRANT o NIX da usare come DEMO per far vedere il progetto

TODO fare merge coi miglioramenti di Luca Gallinari nel branch canvas:
alcuni non sono da unire dato che aggiungono attacco BURST e altre cose del genere

*** TODO Tournament 
TODO test the installation and usage on Ubuntu and Debian

TODO prepare instructions for running the application on different environments

TODO think to rule games, and prepare tournaments with different ROOMS with maximum 4 robots

TODO prepare a game server assigning DEMO ROOMS, and repeating tournaments many times

*** TODO Server 

DONE misurare utilizzo CPU per l'arena e vedere quante ne posso supportare durante il torneo:
- il simulatore ne supporta diverse senza problemi
- altri computer devono essere usati per la board dato che e` quello che usa piu` risorse

TODO pensare se creare una machine su NIXOS accessibile dall'esterno o una gestita tramite NIXOPS con l'ambiente di gioco

*** TODO Libreria classica

TODO prepare a final version without old commit history and put on GitHub

DONE fare robot classic
*** TODO Creare libreria FRP
:LOGBOOK:
CLOCK: [2015-10-16 Fri 01:25]--[2015-10-16 Fri 03:06] =>  1:41
:END:
**** TODO appunti sulle librerie esistenti 
***** Requirements

Usa le monads e possibilmente non le arrows.

Gestisce eventi.

Gestisce segnali continui.

Ha concetto di stato.
***** FRP
Elerea dice di risolvere il problema di Fran (space leak) e il problema di local-time libraries (non composability).

Functional Reactive Programming (FRP) is becoming an increasingly common way to structure event- driven code, but the term "FRP" actually refers to a large body of increasingly diverse work. This talk will quickly cover the basics of FRP, and then go into a couple different formulations of FRP that people are beginning to use. We will explore how these formulations fit together historically and theoretically.

Il sito https://github.com/gelisam/frp-zoo paragona diverse librerie usando uno stesso programma.

Ci sono librerie che hanno solo STATIC GRAPHS e altre con DYNAMIC GRAPHS.

Behaviour: un valore che dipende dal tempo in modo continuo.

Event: un evento che c'e` ad un certo time.

Per rendere veloce l'implementazione, le FRP adesso non permettono di usare funzioni direttamente, ma solo di combinare insieme un pre-set iniziale di funzioni efficienti, per crearne di piu` complesse ma sempre efficienti.

Dicono che uno deve imparare Applicative e altri concetti, ma poi paga. https://wiki.haskell.org/Typeclassopedia

Quelle che meritano di essere studiate:
- reactive banana: efficient, no space-leak, molti esempi, si puo` unire ad altre librerie, una delle piu` facili da capire, usa applicative invece che gli arrows
- netwire: sembra adatta per robot, piu` di reactive banana, sembra arrow-based, piu` difficile da usare di reactive-banana

Scartate:
- sodium: sorpassata da Reactive Banana
- Yampa: proof of concept not anymore maintaned
- Animas: 
- reflex: orientata a DOM e UI
- elerea: non ha events, ma solo behaviours. Troppo rischiosa, dato che meno usata di netwire e banana

Le ultime FRP non hanno una Monadic interface, dato che tende ad introdurre space-leaks e non predictable times. Yampa e Netwire e Reactive Banana seguono questa filosofia di non avere una interfaccia Monadic.

Impressione: quando il grafo diventa complesso, e` piu` facile lato implementazione, un aproccio alla Emil in cui si costruisce un compiler, invece che un EDSL che non puo` fare una fase di analisi prima.


***** Linear Algebra and Controllers
***** Fuzzy
***** Robotics in generale
L'argometo e` sicuramnte complesso.
**** TODO creare wrapper fra librerie e Netrobots
TODO forse si puo` avere una fase di integration in cui si scrivono delle librerie in comune per rendere piu` espressivi i ROBOT estendendo la MONAD e quant'altro e si puo` fare come side-project dopo

TODO far vedere il codice di un robot semplice scritto in maniera naive e confrontarlo con un aproccio alla YAMPA

TODO vedere lo stato come si gestisce

*** TODO creare libreria di funzioni trigonometriche 
- includere conversioni fra angoli di gioco e angoli trigonometrici
- calcolare distanze
- ecc..

* Battle Field Organization

Preparare un server NixOS / NixOPS che faccia da WEB locale e/o CHAT per dirigere un po' tutte le operazioni.

Preparare poi una serie di SERVERS NetRobots su differenti porte che accettano combattimenti di diverse arene.

NixOS permette di specificare i servizi in modo elegante e portabile e NixOPS di creare delle VM pronte a gestire il tutto.

NixOPS gira anche sotto Mint come HOST e quindi e` estremamente portabile e usabile.

* Traccia Talk

TODO mettere i commenti relativi a ZMQ e simili nel codice di template, invece che nel talk
 
TODO mentre loro leggono far vedere i robots che si sfidano per dare un'idea del tutto

TODO far vedere differenza fra codice imperativo non reattivo e codice reattivo e spiegare perche` serve in quel modo

TODO scrivere qualcosa tipo: il robot cosi` specificato e` essenzialmente stupido perche` non riesce a reagire agli eventi e stimoli del mondo esterno, ma procede secondo il suo piano prestabilito. Non e` neanche facile capire come poter estendere il codice per renderlo reattivo.

TODO dividere la paper in esercizi semplici iniziali per guidare il robot da una posizione all'altra e cose di questo tipo, per far fare pratica con la libreria

TODO non deve essere la soluzione definitiva alla robottica anche perche` non esiste e sconfina nella AI nei casi estremi. Quindi deve essere qualcosa che diverte.

TODO provo a scrivere anche io dei robot di esempio per vedere come butta.

